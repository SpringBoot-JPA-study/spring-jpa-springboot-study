# ❰❰ 04. CPU의 작동원리 ❱❱

### CPU 간단요약

- 제어장치 (CU: Control Unit)
- 연산장치 (산술논리연산장치 ALU :  Arithmetic Logic Unit)
- 저장장치 (레지스터)

# [ 04-1. ALU와 제어장치 ]

## [ 1 ] ALU

### { 1 }  ALU입출력과 연산

<center>
  <img
    src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0f/ALU_block.gif/1200px-ALU_block.gif?20141125142634"
    width="510"
    height="250"
  />
</center>

</br>

→ ALU 그림 필요

- **ALU의 입력**
    - 제어신호 :   수행할 연산을 알려준다.
    - 피연산자 :   레지스터를 통해 받는 계산할 내용
    - 플래그(상태)
- **ALU의 출력**
    - 플래그(상태)
    - 결과값 :   연산수행 결과
        - 특정숫자나 문자가 될 수도 있고, 메모리 주소가 될 수도 있다.

### { 3 } 플래그 flag

연산결과에 대한 추가적인 상태정보.

**대표적인 플래그들**

- 부호 플래그
- 제로 플래그
- 캐리 플래그
- 오버플로우 플래그
- 인터럽트 플래그
- 슈퍼바이저 플래그

**플래그 레지스터**

→ 플래그를 저장하는 레지스터

### { 3 }  기타 ALU에는 여러가지 계산회로들이 있다.

ex) 가산기(덧셈), 보수기(뺄셈), 시프터, 오버플로우 검출기 등

---

## [ 2 ] 제어장치

### { 1 } 제어장치 기능

- 제어신호 생성
    
    :  컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기신호
    
- 명령어 해석

### { 2 } 제어장치와 상호작용하는 부품 ( 입출력과 연관 )

- 클럭
- 명령어 레지스터
- 플래그 레지스터
- CPU내부
    - CPU레지스터
    - ALU
- CPU외부 제어버스
    - 메모리
    - 입출력장치

### { 3 } **제어장치 입출력 정보**

→  CPU제조사마다 다르다.  제어장치의 구현방식, 명령어해석방식, 입출력 정보 등이 조금씩 차이가 있다.

1. **입력**
    - **1) 클럭신호**  ← 클럭 생성
    - 2**) 명령어** ← 명령어 레지스터
    - **3) 플래그** ← 플래크 레지스터
    - **4) 제어신호**   ← 시스템버스 그 중에도 제어 버스로 전달되 제어신호
2. **출력**
    - **제어신호**  ⇒  CPU 내외부의 각 장치들에 제어신호를 보낸다.

### { 4 } 입력

**클럭 신호**

크래시코스 컴퓨터 사이언스에서 배운 것처럼.  컴퓨터도 기계들처럼 부품들이 서로 박자를 맞추어 움직여야한다. 그 전기신호. 

클럭에 맞추어 컴퓨터의 부품과 명령어들이 작동하지만, 한 클럭마다 작동하는건 아니다. 여러 클럭, 즉 여러 박자에 걸쳐 작동할 수 있다. 하지만 기본은 그 박자의 맞춰서 움직이겠지.

**명령어, 해석해야할 명령어**

명령어 레지스터에 저장한 명령어를 받아들이고 해석

명령어에 해당되는 제어신호를 발생시켜, 컴퓨터 부픔들이 특정한 수행을 하도록 함

**플래그 값**

플래그는 제어할 때 중요한 참고정보이기에, 플래그를 받아들여 관련된 제어신호를 발생

**입력 제어신호**

CPU뿐만 아니라, CPU외부장치에서 전달되 제어신호를 받아들인다.

### { 5 } 출력

**제어신호**

- **CPU내부에 전달**
    - “레지스터”를 제어 →  레지스터 간 데이터 이동 및, 저장된 명령어 해석하기 위해
    - “ALU”를 제어 → 수행할 연산을 지시
- **CPU외부에 전달 (제어버스를 통해서)**
    - 메모리 →  메모리 Read Write 등.
    - 입출력장치 →  메모리처럼 Read Write 등

---

# [ 04-2. 레지스터 ]

## [ 1 ] 레지스터

정보를 가지고 작업을 하려면, 정보가 담길 공간 혹은 그릇이 있어야한다.

레지스터는 CPU에서의 그릇이다. 우리가 일반적으로는 주기억장치_메모리와 보조기억장치만 신경쓰지만, CPU작업 또는 연산에서는 레지스터가 중요하다.

## [ 2 ] 레지스터 종류

### 0. 대표적 레지스터들 8가지

**서론**

- CPU마다 레지스터는 다양하다. 구체적인 내용은 CPU제조사를 통해 알 수 있다.
- 우리가 배워야할 것은 전공서적에서 중요하게 다루거나, 많은 CPU가 일반적으로 가지는 주요 레지스터를 공부한다.

1. **프로그램 카운터**
2. **명령어 레지스터**
3. **메모리 주소 레지스터**
4. **메모리 버퍼 레지스터**
5. **플래그 레지스터**
6. **범용 레지스터**
7. **스택 포인터**
8. **베이스 레지스터**

### 1. 프로그램 카운터

- PC :  Program Counter
- 명령어 주소 레지스터
    - 명령어의 주소를 저장
    - 명령어 포인터 (명령어 포인터 레지스터)
- **프로그램 실행 단계에서 첫번째 중요한 역할**
    - 시작할 프로그램의 명령어 주소를 저장하고
    - 명령어가 다 실행되면, 다음 명령어 주소로 증가한다.
    - 즉,  Counter라는 말이 쓰여진 것처럼, 지속적으로 증가하면서 다음 명령어를 읽어들일 준비를 한다.
- 변위 주소 지정 방식의 하위인 “상대 주소 지정 방식”에서도 쓰임

### 2. 명령어 레지스터

- IR : Instruction Register
- 명령어 레지스터
    - 메모리에서 읽어들인 명령어를 저장

### 3. 메모리 주소 레지스터

- MAR :  Memoery Address Register
- 메모리의 주소 레지스터
- “주소 버스”로 주소값을 보낼 때, 메모리 주소 레지스터를 거침
- 프로그램 카운터랑 헷갈리지 않기

### 4. 메모리 버퍼 레지스터 (메모리 데이터 레지스터)

- MBR :  Memory Buffer Register
    - 또는 직관적으로 MDR :  Memory Data Register 라고도 불림
- 메모리의 값, 즉 명령어와 데이터 자체를 저장
- 메모리에서 읽거나, 메모리로 쓸 값들이 지나간다.
- 당연히 “데이터 버스”와 연관되어있다.

### 5. 범용 레지스터

- gerneral purpose register
- 범용, 즉 데이터와 주소를 모두 저장할 수 잇다.
- 이름 그대로 다양하고 일반적인 상황에서 자유롭게 사용

### 6. 플래그 레지스터

- 말 그대로 플래그 레지스터

### 7. 스택 포인터 -  주소 지정 방식 관련 레지스터

- 스택 주소 지정 방식에 사용
    - 스택과 스택 포인터를 사용
- “스택의 꼭대기”를 가리키는게 스택 포인터
- 스택에 마지막으로 저장한 값의 “위치”를 저장

### 8. 베이스 레지스터 - 주소 지정 방식 관련 레지스터

- 변위 주소 지정 방식의 하위 “베이스 레지스터 주소 지정 방식”에 사용됨

## (참고) 프로그램 카운터와 명령어 실행 작동방식

1. 프로그램 카운터에 시작할 명령어 주소 저장되어있음.
2. 시작 명령어 주소 ⇒ 메모리 주소 레지스터 전달
3. 버스를 통한 전달
    1. 제어신호 (메모리 읽기라는 명령) ⇒ 제어버스
    2. 메모리 주소 ⇒ 주소버스
4. 메모리 값 읽기
5. 메모리 값 (시작 명령어) ⇒ 메모리 버퍼 레지스터 에 저장 (메모리 데이터 레지스터)
    1. 메모리를 읽으라는 명령이 실행되고
    2. *** 프로그램 카운터 값 증가
6. 메모리 버퍼 레지스터 ⇒ 명령어 레지스터에 저장
7. 명령어 해석 :  제어장치가 명령어 레지스터의 명령어 해석
8. 명령어에 따른 제어신호 발생 ⇒ 실행
9. 프로그램 카운터에 저장된 다음번 명령어 주소 → 앞의 순서대를 다시 따르면 실행

---

## 주소 지정 방식 따로 정리

- “즉시” 주소 지정 방식
- “직접” 주소 지정 방식
- “레지스터” 주소 지정 방식
- “레지스터 간접” 주소 지정 방식
- “스택” 주소 지정 방식
- “변위” 주소 지정 방식
    - “상대” 주소 지정 방식 - 프로그램 카운터 사용
    - “베이스 레지스터” 주소 지정 방식

---

# [ 04-3 명령어 사이클과 인터럽트 ]

## [ 1 ] 명령어 사이클

### 1. 설명

주기. 명령어가 실행되는 일정한 주기

명령어들을 처리하는 정형화된 과정이 반복되는 주기

(또는 정형화된 명령어 처리과정의 반복흐름의 주기)

### 2. 명령어 사이클의 세부주기

- **인출 사이클**
    
    메모리부터 명령어를 CPU가 인출하는 단계
    
- **실행 사이클**
    
    가져온 명령어를 실행하는 단계
    
- **간접 사이클**
    
    메모리 접근이 더 필요한 경우, 추가적 메모리 접근 단계 
    
    ex) 간접 주소 지정 방식 처럼. 메모리 접근이 더 필요할 때
    
- **인터럽트 사이클**

## [ 2 ] 인터럽트

### 설명

명령어 사이클이 끊어지는 것. 또는 그것을 발생시키는 신호

즉 CPU가 수행 중인 작업이 잠시 중단되는 것. 또는 중단을 발생시키는 신호

더 중요한 작업이 있으니 이것을 먼저 해달라는 신호

### 인터럽트 종류

인터럽트를 구분하는 정해진 기준이 없이 CPU마다 다르다.

교재는 인텔 CPU를 기준으로 한다.

- **동기 입터럽트 (synchronous interrupts)  :   (예외)**
    - “CPU”에 의해 발생하는 인터럽트
    - 예외적인 상황에 마주쳤을 때 발생시킨다.
        
        ex) 포로그래밍상의 오류
        
    - **“예외(exception)”** 라고도 부른다.
- **비동기 인터럽트 (asynchronous interrupts) :   (하드웨어 인터럽트)**
    - 주로 “입출력장치”에 의해 발생하는 인터럽트
    - 일반적으로 인터럽트라고 하면, 이 비동기 인터럽트를 의미
    - **“하드웨어 인터럽트”**라고도 불림
        - 1) 막을 수 있는 인터럽트
        - 2) 막을 수 없는 인터럽트 (ex: 하드웨어 고장 인터럽트)

- 추가내용) 예외의 종류
    - 1) 폴트
    - 2) 트랩
    - 3) 중단
    - 4) 소프트웨어 인터럽트
    
    ---
    

## [ 3 ] 하드웨어 인터럽트

### {1} **사용목적**

입출력장치가 작업을 하는 시간동안, CPU가 다른 작업을 할 수 있도록 하기 위해서.

CPU가 입출력장치를 기다리는게 아니라, 입출력장치가 CPU로 “알림”을 보낼 수 있도록 한다.

따라서 일종의 “알림” 이다.

### {2} 관련 개념들

- **CPU가 인터럽트를 처리한다는 뜻**
    
    **:   해당하는 인터럽트 서비스 루틴을 실행하고, 본래 수행작업으로 되돌아온다.**
    
- **인터럽트 요청 신호**
    
    **:  CPU의 작업을 방해하는 인터럽트에 대한 요청**
    
    - 인터럽트 하기 전에, CPU에게 인터럽트 가능한지 요청하는 과정
- **인터럽트 플래그**
    
    **:  인터럽트 요청 신호를 받아들일지 여부를 결정하는 비트**
    
    - 하드웨어 인터럽트를 받아들일지, 무시할지, 현재의 상태에 대한 플래그
    - CPU가 중요한 작업을 처리하거나, 방해받지 않아야할 때가 있기 때문에.
    - 인터럽트 플래그가 가능 상태로 되어있어야한다.
    - 단, 하드웨어 고장 인터럽트는 불가능 플래그 상태도 이길 수 있다고 한다.
- **인터럽트 벡터**
    
    **:  인터럽트 서비스 루틴의 식별정보, 루틴의 시작 주소를 포함한다.**
    
    - 인터럽트 서비스 루틴의 메모리 상 시작 주소를 알 수 있다.
    - 인터럽트 서비스 루틴도 프로그램이니까, 프로그램 카운터 등의 레지스터를 사용하여 작동한다. → 따라서 원래 하던 작업의 레지스터 정보들은 메모리상에 백업시켜놓아야한다.
- **인터럽트 서비스 루틴**
    
    **:  인터럽트를 처리하는 프로그램**
    
    - 인터럽트를 처리하기 위한 프로그램
    - 인터럽트 핸들러 라고도 불림
    - 입출력장치마다 루틴이 다르다.

### {3} **하드웨어 인터럽트 처리 순서**

1. **인터럽트 요청 신호**
    
    입출력장치 → CPU로 인터럽트 요청 신호
    
2. **CPU의 인터럽트 여부 확인**
    
    :  CPU의 주기적 인터럽트 여부 확인 → 실행사이클이 끝나고 명령어 인출 전에, CPU는 항상 인터럽트 여부를 확인한다.
    
3. **인터럽트 플래그 확인**
    
    :  현재 인터럽트를 받아들일 수 있는지 여부 확인
    
4. **작업 백업** 
    
    :  인터럽트를 받아들일 수 있다면, CPU는 지금까지의 작업을 백업한다.
    
5. **인터럽트 벡터를 확인하여, 인터럽트 서비스 루틴 실행**
6. **인터럽트 서비스 루틴 관련 작업 실행**
7. **백업 작업 재개** 
    
    :  인터럽트 서비스 루틴 관련 실행이 끝나면, 원래 하던 작업을 재개한다.
