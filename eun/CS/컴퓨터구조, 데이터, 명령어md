# ❰❰ 01. 컴퓨터 구조 시작하기 ❱❱

# [ 01-1. 컴퓨터 구조를 알아야하는 이유 ]

## 컴퓨터 구조 공부이유

### 문제해결

- 문제해결의 실마리를 얻을 수 있다.
- 각종 기술 면접에서도 컴퓨터 구조에 관한 소양을 필요로 한다.

### 성능,용량,비용 계획

- 시스템 및 서버를 구현할 때, 합리적인 선택을 할 수 있게 한다.

# [ 01-2. 컴퓨터 구조의 큰 그림 ]

## 컴퓨터 구조 큰 얼개

1. **컴퓨터가 이해하는 정보**
2. **컴퓨터의 핵심부품 4가지**

## **컴퓨터가 이해하는 정보**

### 1. 데이터 (data)

### 2. 명령어 (instruction)

## **컴퓨터의 네 가지 핵심 부품**

### 1. CPU

### 2. 주기억장치 (main memory)

### 3. 보조기억장치 (secondary storage)

### 4. 입출력장치 (input/output device)

### 5. 추가) 메인보드와 시스템버스

## 메모리

### 설명

- 명령어와 데이터 저장
- 단, 현재 실행되는 프로그램의 명령어와 데이터

### 메모리 주소

- address :   메모리의 특정 위치에 접근하는데 사용 식별자

## CPU

### CPU 핵심 3가지

- 제어장치 CU :  Control Unit
    - 명령어를 읽고 해석하는 장치
    - “제어신호 control signal” :  컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기신호
    
    ex) 메모리 읽기 신호, 메모리 쓰기 신호
    
- 레지스터  Resister
    
    → CPU의 저장장치
    
- 산술논리연산장치 ALU :  Arithmetic Logic Unit
    
    → 계산기
    

CPU 움직임 간략정리

→ 자세한 내용은 04장, 05장

## 보조기억장치

- 주로 비휘발성
- 보관할 프로그램을 저장한다. (메모리가 실행되는 프로그램을 저장한다면)

## 입출력장치

→ 08장 자세히

## 시스템버스와 메인보드

### 메인보드 (마더보드) :  여러 부품들을 부착할 수 있는 곳

### 버스 bus :   부품끼리 정보를 주고받는 통로

### 시스템 버스 system bus :   네 가지 핵심부품을 연결한다.

- 시스템버스 주요구성
    - 주소 버스 address bus :   주소
    - 데이터 버스 data bus :   데이터와 명령어
    - 제어 버스 control bus :   제어신호
    
    ---
    

---

# ❰❰ 02. 데이터 ❱❱

# [ 02-1. 이진법 ]

## 정보단위

- 비트
- 바이트
- 워드 → CPU가 한 번에 처리할 수 있는 데이터 크기 (ex: 32비트, 64비트 컴퓨터)

## 이진법

**이진법 기호**

**→ 이진법 숫자라는 걸 표시하는 상징기호** 

- 숫자 끝에, 작은 (2) 붙임
- 숫자앞에 0b 붙임

**이진수의 음수 표현**

→ 2의 보수 이해해야함.

# [ 02-2. 문자 표현 ]

## 문자집합과 인코딩

## 핵심개념 3가지

**→  :   문자 집합, 인코딩, 디코딩**

- 문자 집합 character set :   컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- 문자 인코딩 character encoding :   문자 집합의 문자를 바이너리로 변환하는 과정
- 문자 디코딩 character decoding :   바이너리를 문자로 변환하는 과정
- 

## 문자집합들

- 아스키모드
- EUC-KR
- 유니코드와 UTF-8

기타 개념

- 완성형 인코딩
- 조합형 인코딩

UTF-8 더 이해

- 인코딩 결과는 1바이트 ~ 최대 4바이트까지


# ❰❰ 03. 명령어 ❱❱

# [ 03-1. 소스코드와 명령어 ]

→ 컴퓨터가 이해하는 건, 명령어와 데이터 뿐.

→ 따라서, 소스코드는 컴퓨터가 이해하는 명령어로 변환되어야한다.

## **코드의 분류**

- 소스코드
- 목적코드
- 실행코드

## 언어의 분류

### 분류기준 (1)

- **저급언어** (low-level programming language)
    - 기계어
    - 어셈블리어
- **고급언어** (high-level programming language)

### 분류기준 (2)

- 컴파일 언어
- 인터프리터 언어

### 저급언어

- 컴퓨터가 직접 이해하고 실행할 수 있는 언어.
- 명령어들로 이루어져있다.
    
    
    **기계어**
    
    - machine code
    - 0과 1의 비트로 이루어진 언어
    - 때로는 가독성을 위해 16진수로 표현하기도 한다.
    
    **어셈블리어**
    
    - 비트로 이루어진 명령어를 읽기편한 단어기호 형태로 대체하여 표현 (약간 1:1 대응 느낌)
    - 소스코드에 어셈블리어를 넣어서 사용하는 경우가 있다.
    - 시스템 SW개발자, 임베디드 SW개발자. 게임 개발자 등

### **고급언어**

- high-level programming lanugage
- 사람이 이해하기 쉬운 언어

## 컴파일, 인터프리터

고급언어에서 저급언어로 변환과정 방법

컴파일

소스코드를 목적코드로 변환

인터프리터

소스코드를 한 줄씩 실행

번역과 통역이라는 비유를 들면 편함

2가지 장단점

컴파일 언어와 인터프리터 언어를 완전히 구별되는건 아님.

왜냐하면 언어들은 2가지 방법을 모두 사용하는 경우가 많기 때문이다.

## 기타 :   목적파일, 실행파일과 링킹

- 목적파일:  목적코드로 이루어진 파일. 목적 코드는 컴퓨터가 이해하는 코드.
- 실행파일:  실행코드로 이루어진 파일
- 링킹
    
    목적코드가 실행파일이 되기 위해서 링킹이라는 작업이 필요.
    
    목적코드는 소스코드에서 만들어진 것이고, 소스코드 자체는 외부기능들을 다 가지고 있지 않다. 따라서, 목적코드가 사용하는 외부기능들(아마 라이브러리?)을 연결시켜야지, 진짜로 그 자체로 실행될 수 있는 실행파일이 된다.
    
    페이지 087
    

---

# [ 03-2. 명령어의 구조 ]

→ 저급언어 명령어의 연산코드, 오퍼랜드, 주소지정알아보기

## 명령어의 구조

- 구조 : 연산코드 + 오퍼랜드
    - 연산코드 operation code
        
        : 명령어가 수행할 연산
        
    - 오퍼랜드 operand
        
        : 연산에 사용할 데이터, 또는 그 데이터의 저장위치
        

## 오퍼랜드

데이터를 담을 수 있지만, 많은 경우에는 그 데이터를 주소를 저장하는데 사용한다.

그래서 주소필드라고도 불린다.

오퍼랜드의 갯수의 따른 명령어 구분

- 0-주소 명령어 ~ 3-주소 명령어

## 연산 코드

수행할 연산을 의미

큰 유형 4가지

1. 입출력 제어
2. 제어 흐름 변경
3. 데이터 전송
4. 산술/논리 연산

명령어의 종류와 생김새는 CPU마다 다르다. 따라서 원리를 이해하는데 초점을 맞추자.

## 주소지정방식

오퍼랜드에 데이터를 직접 넣지 않고, 주소를 넣는 이유

→ 명령어의 길이, 즉 저장용량의 한계가 있기 때문에

연산코드가 길어질 수록, 오퍼랜드 갯수가 많아질 수록, 오퍼랜드에 할당되는 비트 수는 적어진다. 

유효 주소 effective address

연산의 대상이 되는 데이터가 저장된 위치

주소 지정 방식 addressing mode

(연산에 사용할) 데이터 위치를 찾는 방법, 유효 주소를 찾는 방법

주소지정방식은 CPU에 따라 다양하다. 대표적으로는 5가지를 들 수 있다.

방식 5가지

- 즉시 주소 지정 방식
- 직접 주소 지정 방식
- 간접 주소 지정 방식
- 레지스터 주소 지정 방식
- 레지스터 간접 주소 지정 방식
