# < 플러시__ (7강) >

## [ 플러시 ]

- 영속성 컨텍스트의 변경내용을 DB에 반영
- 영속성 컨텍스트와 DB를 동기화 시키는 것.
    - 즉, 영속성 컨텍스트를 비우는게 아니다.
- 동기화시키기 위해, SQL을 DB에 적용하게 된다.
- 트랜잭션이라는 작업단위가 중요하다.
    - 데이터베이스의 트랜잭션 개념에 의존한다.
    - 커밋 직전에만 동기화하면 된다.

## [ 플러시 작동방식 ]

- 변경감지 (Dirty Checking)
- 변경된 엔티티를 → 쓰기 지연 SQL에 저장소에 “등록”
- 쓰기지연SQL저장소에 쿼리를 DB에 전송
    - 엔티티에 가해졌던, 쿼리들(등록,수정,삭제)이 누적되어 저장되어 있음

## [ 플러시 시점 ]

→ EntitiyManager에 persist() 할 때는 플러시가 되지 않는다.

아래 3가지 경우에서 플러시가 된다.

- 직접호출 em.flush()
- 트랜잭션 커밋
- JPQL 쿼리 실행

## [ JPQL 쿼리 실행 시 플러시가 자동으로 호출되는 이유 ]

→ 일단 간단하게 요약해보려고 한다면,

마땅히 DB에 반영되어야할 내용이지만, 아직 플러시가 되지 않아서 반영을 기다리는 경우가 있을 수 있다. 이러한 경우 플러시를 하지 않은 채로, 반영내용에 대한 JPQL조회를 하게 되면, 반영 전의 잘못된 결과가 나올 수 있다.

조회를 할 때는 제대로 된 DB내용이 나와야한다. 따라서 플러시를 해서, 제대로 반영시킨 다음에 조회를 해야만한다.

&nbsp; &nbsp; **예를 들어)**

&nbsp; &nbsp; 수업을 열심히 듣고 수업내용을 노트정리 해놓았다. 그런데 아직 노트정리 내용을 기억 또는 암기하지 않았다고 해보자. 이런 상황에서 시험 보면 말짱 꽝이다. 의미없는 노트정리이다. 노트정리한 내용을 머리 속에 기억하고, 그다음 시험을 봐야한다.

&nbsp; &nbsp; - 수업내용 :  그동안의 비즈니스 트랜잭션? (용어 애매함)

&nbsp; &nbsp; - 노트정리  :   지연SQL저장소 내용

&nbsp; &nbsp; - 기억 또는 암기 :  플러시

&nbsp; &nbsp; - 시험 :  조회

## [ 플러시 모드 옵션 ]

1. FlushModeType.AUTO
    
    → 위에서 작성한 플러시가 되는 시점 3가지가 디폴트
    
2. FlushModeType.COMMIT
    
    → 커밋할 때만 플러시 반영되는 것으로.
    
    
---
---
---

# < 준영속 상태__(8강) >

## [ 준영속 상태 ]

- 영속상태와 비교해보자.
    - 영속상태 :   1차 캐시에 올라가고, EntityManager의 관리를 받는 상태
    - 준영속 상태 :   영속 상태였던 엔티티가 영속성 컨텍스트에서 분리(Detached) 됨.
- 따라서, 엔티티 매니저와 관리를 받지 못하고, 영속성 컨텍스트가 제공하는 기능을 사용하지 못함.

## [ 비영속과 준영속의 차이는 무엇인가? ]
    
- 공통점 :  비영속이나 준영속이나 영속성 컨텍스트의 기능을 사용못하는 것을 동일하다.
- 차이점 :
    - 준영속 상태의 경우, 해당 엔티티는 DB에 한번 반영되었던 녀석이다.
    - 식별자 :   준영속 상태의 엔티티, 즉 준영속 엔티티는 식별자가 존재한다. 즉, 영속성 컨텍스트 상에서 관리되면서, DB에 한번 갔다 온 녀석이기에 따로 식별자로서의 아이디를 가지고 있다.

    &nbsp;정보소스
    
    &nbsp;[[JPA] 준영속 상태와 변경 감지](https://velog.io/@wogud7587/JPA-%EC%A4%80%EC%98%81%EC%86%8D-%EC%83%81%ED%83%9C%EC%99%80-%EB%B3%80%EA%B2%BD-%EA%B0%90%EC%A7%80)
    

## [ 준영속 상태로 만드는 방법 ]

- em.detach(entity) :   특정 엔티티만 준영속 상태로 전환
- em.clear() :   영속성 컨텍스트를 완전히 초기화
- em.close() :   영속성 컨텍스트를 종료
