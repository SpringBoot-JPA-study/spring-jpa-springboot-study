# TIL ( 2023.01.19 )

### DAY 7

## 🔖 오늘 읽은 범위 : 에피소드 22 ~ 25

---


##  😃  기억하고 싶은 내용

- 처음에는 프로그램이 돌아가는 수준으로 개발해. 코딩은 다 했고, 버그도 없어. 그다음 단계로 코드를 정리하지. 관리하기도, 협업하기도 편하도록! 효율적인 코드, 속도가 빠른 코드를 고민하게 돼. 이때 자료구조와 알고리즘이 필요해. 그럼 이 둘은 구체적으로 무엇일까? (p.132 ~ p.133)
- 택배 회사의 창고에 짐을 마구잡이로 쌓아 놓았다면, 그 회사는 금방 망할 거야. 왜냐하면, 고객의 물건을 찾는데 시간이 엄청 오래 걸릴 테니까. 이런 필요성 때문에 공부해야하는 것이 바로 자료구조야! (p.135)
- 컴퓨터도 마찬가지야. 데이터를 보기 좋게 보관하는 것을 넘어서 찾기 좋게 제대로 보관해야 해. 어떤 자료구조를 사용하는지에 따라 프로그램 속도가 빨라지거나 느려지거든. (p.136)
- 배열의 특징을 이야기하려면, 배열에서 자주 벌어지는 사건을 알아야 해. 바로 읽기(read), 검색(search), 추가(add), 삭제(delete)과정에서의 시간 복잡도(time complexity)말이야. 시간 복잡도는 자료구조, 알고리즘을 공부할 때 꼭 알아야 하는 개념이니까 이것부터 설명할게.(p.137)
- 배열에서 데이터를 찾는 속도는 매우 빨라! 애초에 몇 번째 데이터를 보라고 하기 때문이지. 즉, 1단계 알고리즘을 가졌기 때문이야. 앞에서 작업 속도는 단계를 적게 거칠수록 빠르다고 했지? 배열을 읽는 속도는 1단계이므로 굉장히 빨라! 그럼 배열에서 데이터를 검색하는 원리와 속도는 어떨까?(p.141)
- "선형 검색 알고리즘은 배열의 길이가 N일 때 총 N번 검색하는 과정이 필요하다."라고 말하는 것보다 "선형 검색 알고리즘의 시간 복잡도는 O(N)이다."라고 말하는 게 더 간단하기 때문이야.(p.145 ~ p.146)
- 배열의 길이와 상관없이, 이 함수는 딱 한 번 실행하고 끝날 거라는 거야. 왜냐하면 첫 번쩌ㅐ 데이터만 출력하는 함수니까! 배열의 길이가 10이라도, 100이라도 이 함수는 단 한 번 실행하지. 그래서 이 함수의 시간 복잡도는 O(1)이야. 그리고 이걸 '상수 시간이(constant time) 내에 실행된다.'라고 이야기하기도 해.(p.146)
- 또 다른 시간 복잡도로 **이차 시간(quadratic time)** 이 있어. 이차 시간은 중첩 반복문이 있을 때 발생해.(p.148)

## 🤔 오늘의 파트에 대한 소감
- 오늘의 에피소드들은 한 글자도 빠짐없이, 기억하고 싶었던 내용이었다. **자료구조, 알고리즘, 배열, 시간 복잡도** 등과 같은 개념들에 대해 더 친밀하게 다가갈 수 있도록 하는 내용이었다. 그렇다보니, 기억하고 싶은 내용, 추가로 알게 된 것 의 글이 아주 많은 듯 하다.
- 어렵게 느껴졌던 개념들을 쉽게 비유해주셔서, 정말 책의 저자분들에게 감사하다는 생각이 들었다.
- 딱딱하게만 느껴졌던 개념들이 친숙하게 다가왔으니, 다시 딱딱하지만 정석으로 설명했던 개념들을 곱씹어보며, 전문가들이 쓰는 언어로도 다시 정리해보아야겠다. 
- 어렵게 말하는 것이 좋은 것은 아니나, 오피셜하게 쓰는 용어와 설명들은 전문가로서 필요하다는 것이 개인적인 생각이다. 
- 선형 검색, 이진 검색 알고리즘에 대해 훨씬 더 직관적으로 이해할 수 있었다. 이 외에도, 다른 알고리즘들도 이 책에서 설명한 방식처럼 간단히 설명할 수 있도록 해야겠다. 그 전에는 이 알고리즘들을 알고있다라고 말했던 의미가 그저, 정처기 시험에서 관련 문제를 풀 수 있다. 라는 의미였던것 같다. 이 에피소드를 보며, '나는 텍스트만 알고 있었지, 해당 개념에 대해 전혀 이해하고 있지 않았었다.'라는 생각이 들었다. 

## 🔎 추가로 알게 된 것 (책 내용 +알파로 궁금한 것, 이해가 가지 않는 것 등)

- **'시간 복잡도'**
  - 프로그램의 작업 속도가 얼마나 빠른지 측정하는 방법이야. 예를 들어, 배열에서 특정 값을 검색하는 시간, 특정 값을 특정 위치에 추가하는 시간 등등 이런 것 말이지! 그런데 시간 복잡도는 '준비-시-작!' 뭐 이런 식으로 실제 시간을 재지 않아. 그 대신 작업이 얼마나 많은 단계를 거치는지를 측정해. 예를 들어 어떤 작업을 하는데 어떤 코드는 5단계, 어떤 코드는 20단계가 필요하다면? 5단계만 필요한 코드의 작업 속도가 빠르다고 하는거야.
  - 시간 복잡도를 이야기할 때는 **알고리즘으로 작업을 완료할 때까지 걸리는 절차 수 N**을 이용해서 O(N), O(log N)과 같이 표현하는데, 이것을 빅오(Big-O)표기법이라고 하거든? (p.145)
- **램이 속도가 빠른 이유?**
  - 램은 주소지가 적힌 박스가 많이 있는 창고라고 생각하면 돼. 그리고 박스에는 데이터를 1개씩 저장할 수 있고, 박스마다 주소가 각각 있는 거야. 그러면 박스에 보관된 데이터를 빠르게 찾을 수 있겠지!
  - 만약 주소가 없다면, 창고 입구 쪽의 박스부터 모두 뒤져야겠지? 램은 이런 원리로 동작해. 그래서 램의 속도가 빠르다고 하는 것이지.
- **배열에서 검색(search)은 빠르지 않다.**
  - 배열에서 검색과정은 박스를 모두 뒤지는 방법으로 진행돼. 박스를 모두 열어 보고 들어 있는 데이터를 확인하는거지. 그래서 검색은 읽기보다 시간이 많이 필요해.
- 배열에 데이터를 삽입하는 원리와 속도
  - 배열에서 데이터를 삽입하는 시나리오 3가지
    1. 배열의 길이가 5, 현재 0 ~ 4 까지 꽉 찬 상태 -> 가장 마지막에 데이터 삽입
    2. 배열의 길이가 5, 현재 0 ~ 4 까지 꽉 찬 상태 -> 삽입하려고 하는 위치 뒤의 데이터를 1씩 옮긴다. -> 배열의 중간에 데이터 삽입
    3. 배열의 길이가 5, 현재 모두 꽉 찬 상태 -> **새로운 배열을 만들고, 이전 배열을 복사해서 옮긴 다음, 새 데이터 추가**
- 검색 알고리즘 2가지
  1. **선형 검색 알고리즘**
     1. 가장 자연스러운 검색 방법
     2. 맨 처음 배열부터 검색을 시작하여, 원하는 데이터가 나올 때 까지 계속 함
     3. 최악의 경우, 찾으려는 데이터가 제일 마지막에 있으면, 마지막까지 검색해야 한다.
     4. y = x 그래프 형태
  2. **이진 검색 알고리즘**
     1. 배열의 크기가 클 때, 선형 검색 알고리즘보다 좋은 알고리즘
     2. 데이터의 정렬이 끝난 배열에서만 사용할 수 있다. 즉, 특정 자료구조에서만 사용할 수 잇는 알고리즘에 해당
     3. 배열의 중앙에서 검색을 시작한다. 
     4. 단계마다 배열의 절반을 제외할 수 있기 때문에, 배열의 크기가 클 수록, 이진 검색 알고리즘이 빠르다.
     5. y = log x 그래프 형태


## 🤟소감 3줄 요약
- 내가 알고 있다고 생각한 것들을 남들에게 설명하려고 할 때, 머뭇거리기 시작한다면, 아직 이해하지 않은 것이다.
- 적어도 자료구조, 알고리즘과 관련해서 오늘 책에서 본 내용들을 그 전에는 어떤 단어와 설명으로 접했었는지 확인해야겠다.
- 자료구조와 알고리즘 공부, 더 이상 미룰 수 없다.

```
#노마드코더 #북클럽 #노개북 #아침30분독서 
```
