# 프록시

## 왜 써야할까?

- 연관관계가 매핑되어있는 두 클래스인 MEMBER와 TEAM을 함께 조회하는 경우 → 두 테이블을 조인해서 한 번에 가져오면 됨
- MEMBER만 조회하는 경우 → 연관관계가 매핑된 TEAM의 정보를 가져올 필요 없이 MEMBER만 조회하면 됨
- 비즈니스 로직에 따라 어떤 쿼리를 사용하여 최적화시킬지 달라지게 됨

<br>

## 프록시 기초

- `em.find()` : 데이터베이스를 통해서 실제 엔티티 객체를 조회
- `em.getReference()` : 데이터베이스 조회를 미루는 프록시(가짜) 엔티티 객체 조회 (= DB에 쿼리가 안날라가는데 객체가 조회됨)
    - getReference()를 사용하는 시점에는 DB에 쿼리 전달X
    - 실제로 프록시 엔티티를 사용하려는 경우에 DB 쿼리 전
- 프록시는 실제 클래스를 상속받아서 만들어짐
    - 하이버네이스가 내부적으로 프록시를 생성하기 위해 클래스를 상속
    - 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 상관하지 않고 사용할 수 있음
- 프록시 객체는 실제 객체의 참조를 보관하고 있음
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출

<br>

## 프록시 동작 방식

<img src="https://user-images.githubusercontent.com/48792230/216211773-b2a0deb5-9cc7-403f-b2b4-a0a2ccd42efe.jpg" width="600"/>

<br>

## ⭐ 특징

- 프록시 객체는 처음 사용할 때 **한 번만 초기화**
- 프록시 객체를 초기화할 때, **프로시 객체가 실제 엔티티로 바뀌는 것이 아니라**, 프록시 객체를 통해서 실제 엔티티에 접근이 가능하게 함
    - 프록시 객체는 target정보(실제 엔티티의 주소값)를 가지고 있음
    - 그렇기 때문에 **타입 체크시 주의**해야함
        - 프록시 객체랑 실제 객체랑 비교를 하게 될 우려가 있으므로 ==비교를 하면 안됨. (타입 불일)
        - JPA에서 타입을 비교하는 경우 **instance of 사용**!
- **영속성 컨텍스트에 찾는 엔티티가 이미 있으면** em.getReference()를 호출하더라도 프록시 객체가 아니라 **실제 엔티티를 반환**하게 됨
    - 그렇기 때문에 프록시 객체가 영속성 컨텍스트에 target 초기화를 요청하는 경우 영속성 컨텍스트는 항상 DB에 쿼리를 날림
    - **이렇게 동작하는 이유 2가지**
        - (1) 성능 최적화 : 이미 영속성 컨텍스트에 있기 때문에 프록시를 사용하는 것보다 원본을 반환하는게 성능 최적화 입장에서 훨씬 나음 (사실상 프록시 객체를 사용할 때의 이점이 없다고 보는게 맞음)
        - (2) [동일성 보장](https://github.com/SpringBoot-JPA-study/spring-jpa-springboot-study/blob/develop/taeong/JPA2/(2)%20%EC%98%81%EC%86%8D%EC%84%B1%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8.md#:~:text=%EC%9E%88%EB%8A%94%20%EA%B1%B4%20%EC%95%84%EB%8B%98-,%EB%8F%99%EC%9D%BC%EC%84%B1%20%EB%B3%B4%EC%9E%A5,-Member%20member1%20%3D)⭐ : 한 트랜잭션 내에 관리하는 객체는 여러 번 호출되더라도 항상 동일함을 보장함
            - (프록시 객체를 사용하게 되면 타입이 달라지므로 동일하다고 볼 수 없음)
            - 만약 한 트랜잭션 내에서 동일한 클래스에 대해 여러 번 getReference()를 호출한 경우
                - 다른 프록시가 아니라 항상 같은 프록시로 반환함
            - 만약 프록시 객체로 먼저 조회가 되면 이후에 em.find()를 호출하는 경우
                - em.find()에서도 프록시 객체를 반환함
            - **⇒ 같은 트랜잭션이므로 항상 동일함을 보장하기 위해⭐⭐⭐**
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생
    
    ```java
    ...
    Member proxyMember = em.getReference(Member.class, 1L);
    
    em.detach(proxyMember);    /* 준영속 상태가 됨 */
    
    proxyMember.getName();    /* 프록시 초기화 시도 */
    
    // 하이버네이트는 org.hibernate.LazyInitializationException 예외를 터뜨림
    ```
    

<br>

## 프록시 확인 메소드

1. 프록시 인스턴스 초기화 여부 확인
    
    ```java
    entityManagerFactory.getPersistenceUtil().isLoaded(proxyMember);
    ```
    
2. 프록시 클래스 확인
    
    ```java
    proxyMember.getClass();
    ```
    
3. 프록시 강제 초기화
    
    ```java
    Hibernate.initialize(proxyMember);
    ```
    
    - JPA 표준에는 강제 초기화가 지원되지 않지만 하이버네이트에서 지원
    - JPA 표준에서는 proxyMember.getName()처럼 실제 객체의 메소드를 직접 호출해서 강제 초기화하는 방법 사용
