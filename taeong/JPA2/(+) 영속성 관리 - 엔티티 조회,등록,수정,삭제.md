# [영속성 관리 - 엔티티 조회/등록/수정/삭제](https://velog.io/@syleemk/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC)

# 1. 엔티티 조회

find()를 이용해서 엔티티를 조회하는 경우

```java
Member m = em.find(Member.class, 100L);
```

1. JPA는 엔티티를 조회할 때 1차캐시부터 찾는다.
    1. 1차 캐시에 해당하는 키값을 가진 엔티티가 있다면 1차 캐시에서 조회한다. 
    2. 1차 캐시에 해당 엔티티가 없다면 데이터베이스에 조회 쿼리를 날려서 가져온 후 1차 캐시에 저장한다.
2. 1차 캐시에 저장된 엔티티를 반환한다.
3. find()메소드를 중복 호출해서 반환된 여러 개의 엔티티는 1차캐시에 저장된 동일한 값을 가져오기 때문에 항상 동일성을 보장한다.

<br>

# 2. 엔티티 등록

```java
Member m = new Member();
m.setId(100L);
m.setName("이름");

em.persist(m);			//persist = save
```

1. persist()를 하면 해당 엔티티를 1차 캐시에 저장한다.
2. 1차 캐시에 저장되는 동시에 insert쿼리를 작성해서 쓰기 지연 SQL 저장소에 넣어준다.
3. 만약 새로운 객체를 생성해서 persist()하는 경우 1,2번의 과정을 반복한다.
4. 트랜잭션을 커밋하는 시점에 쓰기 지연 SQL 저장소에 있던 쿼리들이 플러시되면서 데이터베이스로 전달된다.
    1. 이렇게 하는 이유는 버퍼링을 이용한 최적화 효과를 보기 위해서! 엔티티를 영속화할 때마다 데이터베이스에 쿼리를 바로 날리게 되면 최적화를 할 수 없다.
    2. 그러나 버퍼에 모아서 한 번에 전달하면 Batch를 이용해서 최적화를 할 수 있다.

<br>

# 3. 엔티티 수정

```java
Member m = em.find(Member.class, 100L);
m.setName("수정된 이름");
```

1. set()을 이용해서 엔티티를 수정하고 트랜잭션을 커밋하게 되면 자동으로 flush()가 호출된다.
2. flush()가 호출되면 JPA는 1차캐시에서 저장된 엔티티와 스냅샷을 비교한다.
    1. 스냅샷 : 최초로 1차 캐시에 들어온 상태를 저장해둔 것
3. 만약 스냅샷과 다른 부분이 있다면 update쿼리를 쓰기 지연 SQL저장소에 넣어둔다.
4. 쓰기 지연 SQL저장소에 저장된 모든 SQL 쿼리들(등록, 수정, 삭제 쿼리)이 데이터베이스로 전달된다. (=플러시)

<br>

# [4. 엔티티 삭제](https://cornswrold.tistory.com/339)

```java
Member m = em.find(Member.class, 100L);
em.remove(m);
```

1. remove()를 호출하면 쓰기 지연 SQL저장소에 delete쿼리를 넣어둔다.
    1. remove()를 호출하는 시점에 해당 엔티티는 1차캐시에서 제거된다.
2. 트랜잭션을 커밋하는 시점에서 플러시가 호출되어 쓰기 지연  SQL 저장소에 등록되어있던 delete쿼리가 함께 전달된다.
