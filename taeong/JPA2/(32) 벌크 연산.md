# 벌크 연산

- 벌크성 쿼리 : 특정 데이터 한 건을 UPDATE, DELETE하는 경우를 제외한 모든 UPDATE, DELETE 경우를 의미
- ex. 재고가 10개 미만인 모든 상품의 가격을 10% 증가시키려면?
    - JPA 변경 감지(더티체킹) 기능으로 실행하게 되면 너무 많은 SQL이 실행됨
        - 10개 미만 재고 리스트 조회
        - 상품 엔티티 가격 10% 증가
        - 트랜잭션 커밋 시점에 변경감지 동작
    - 변경된 데이터가 100건이라면 100번의 UPDATE 쿼리 발생
    - JPA 변경감지는 벌크성보다 실시간성에 최적화되어있기 때문
    - JPA 벌크 연산으로 쿼리 한 번에 여러 테이블 로우를 변경할 수 있음
    
<br>

## 벌크 연산 사용법

- 모든 Member엔티티의 나이를 20살로 수정

```java
int resultCnt = em.createQuery("update Member m set m.age = 20").executeUpdate();
```

- createQuery의 결과값은 변경된 엔티티의 수
- 하이버네이트는 INSERT문(insert into .. select)도 지원함
    
<br>

## 벌크 연산 주의

- **벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리함**
    - 그래서 잘못하면 꼬일 수가 있음
        - (데이터정합성 문제 : 영속성 컨텍스트와 데이터베이스의 값이 달라짐)
    
<br>


- **해결 방법 2가지**

    1. **영속성 컨텍스트에 아무 작업도 하지 않은 상태에서 벌크 연산을 실행**
    2. **영속성 컨텍스트에 데이터가 있다면, 벌크 연산 수행 후 영속성 컨텍스트를 초기화**
        - `벌크 연산이 실행되면 자동으로 flush를 호출`
        - 데이터베이스에는 올바른 값이 들어가지만 영속성 컨텍스트에는 이전 값이 있으므로 이전 값을 사용하게 될 가능성이 있음 → 위험
        - `em.clear()` : 데이터베이스에 있는 최신 값을 영속성 컨텍스트에 갱신해야함
        - Spring data JPA에서는 @Modifying 을 통해 벌크성 쿼리를 날릴 수 있음
