# 상속관계 매핑

- 객체는 상속관계가 있지만 RDB에는 상속관계가 없음
- 슈퍼타입 서브타입 관계가 가장 상속과 유사
- 상속관계 매핑 : 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑

<br><br>

## DB입장에서 구현할 수 있는 세 가지 전략

__1. 조인 전략__ (정석🌟) : 공통 속성을 묶은 테이블과 각각의 상세 테이블을 조인
  - `@Inheritance(strategy = InheritanceType.JOINED)`
  - `@DiscriminatorColumn`
      - 어떤 자식 엔티티에서 저장된 데이터인지 알 수 있도록 부모 테이블에 DTYPE(=상세 테이블명이 입력됨)을 설정하는 옵션
  - __장점__
      - 테이블 정규화
      - 외래키 참조 무결성 제약조건 활용 가능
      - 저장공간 효율화 : 테이블마다 중복되는 칼럼이 없음
  - __단점__
      - 조회 시 조인을 많이 사용하기 때문에 성능 저하
      - 조회 쿼리가 복잡 : 조인을 사용하기 때문에
      - 데이터 저장시 insert쿼리가 2번 호출 (부모 테이블, 자식 테이블)

  ---

<br>

__2. 단일 테이블 전략__ : 상세 테이블에 있는 칼럼을 하나의 테이블에 묶음
  - `@Inheritance(strategy = InheritanceType.SINGLE_TABLE)`
  - default
  - 단일테이블 전략은 `@DiscriminatorColumn`를 지정하지 않아도 됨. 왜냐하면 이미 기본값으로 되어있기 때문!
      - 단일 테이블에서는 DTYPE이 없으면 어떤 자식 엔티티에서 저장되었는지 추적할 수 없음 —> 그래서 DTYPE은 필수적
  - __장점__
      - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
      - 조회 쿼리가 단순
  - __단점__
      - 자식 엔티티가 매핑한 컬럼은 모두 NULL허용 : 데이터 무결성을 고려할 때 좋지 않은 설계
      - 단일 테이블에 모든 것을 저장하므로 테이블이 커지면 오히려 조회 성능이 안좋아질 수 있음

  ---

<br>

__3. 구현 클래스마다 테이블 전략__ (별로❌) : 공통 테이블 따로 만들지 않음. 상세 테이블만 있는 상태
  - `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`
  - 이 옵션을 사용하려면 부모 클래스를 추상클래스로 만들어야함
      - 원래는 부모클래스를 만드는 경우 항상 추상클래스여야 하지만 위의 두 전략은 추상클래스가 아니어도 동작하기는 함
      - 그러나 부모 테이블이 없이 구현 클래스마다 테이블을 만드려는 경우 부모 클래스가 abstract여야 테이블이 자동으로 생성되지 않음
  - 데이터를 입력하는 경우는 괜찮지만 조회하는 경우에 문제가 됨 → 하나의 데이터를 찾기 위해서 모든 테이블을 조회해야할 수도 있음
  - 이 전략은 데이터베이스 설계자와 ORM 전문가가 둘 다 싫어하는 방식
  - __장점__
      - 서브 타입을 명확하게 구분해서 처리할 때 효과적
      - NOT NULL 제약조건 사용 가능
  - __단점__
      - 여러 자식 테이블을 함께 조회할 때 UNION을 사용하기 때문에 성능이 떨어짐
      - 자식 테이블에 공통되는 속성이 있더라도 결국 각 자식 테이블마다 쿼리를 여러 번 날려줘야 함

  ---

<br>

**⇒ 객체는 상속을 지원하기 때문에 객체 입장에서는 세 가지 전략이 모두 동일함**
